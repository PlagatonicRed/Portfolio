<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Game Dev Projects</title>
    <link rel="stylesheet" href="CSS/homePage/containerStyles.css">
    <link rel="stylesheet" href="CSS/homePage/buttonStyles.css">
    <link rel="stylesheet" href="CSS/homePage/textStyles.css">
    <link rel="stylesheet" href="CSS/homePage/footerStyles.css">
    <script src="https://kit.fontawesome.com/bb15663a51.js" crossorigin="anonymous"></script>
    <link rel="stylesheet" href="CSS/gameDevPage/textStyles.css">
    <link rel="stylesheet" href="CSS/gameDevPage/buttonStyles.css">
    <link rel="stylesheet" href="CSS/gameDevPage/containerStyles.css">

</head>
<body>
    <div id="navbar-container"></div>
    <script>
        fetch('menuBar.html')
            .then(response => response.text())
            .then(html => {
                document.getElementById('navbar-container').innerHTML = html;
            });
    </script>

    <!--TODO CHange this to be verticle dividers for each projh -->
    <div class="main">
        
        <div class="main__container">

            <div class="main__img--container">
                <a href="https://xxvoltarxx.itch.io/sterile-coffin" target="_blank">
                    <img src="images/Sterile-Coffin-Cover.png" alt="pic" id="main__img">
                </a>
            </div>

            <div class="content sterile-coffin__content">
                <h1>Sterile Coffin</h1>
                <p>
                    Sterile Coffin is a short, first-person movement shooter set in an
                    abandoned laboratory. As the player, you must escape from this
                    unknown and unnatural environment by fighting your way through waves of
                    enemies.
                </p>
                <button class="btn sterile-coffin__btn">
                    <p class="read-more">Read More</p>
                </button>

            </div>
                <div class="large-text-container">
                    <p>
                        Development Time:
                        6 weeks
                        <br>
                        <br>
                        Team Size:
                        5
                        <br>
                        <br>
                        Goals:
                        <br>
                        Create designer friendly tools
                        <br> Learn how to create a secure save/load system
                        <br> Create clean and reusable scripts.
                        <br>
                        <br>
                        Role:
                        Programming Lead
                    </p>
                    <p><br>
                        One of the most challenging aspects of creating this game was definitely making the movement feel good.
                        My first approach to this problem was simple: make the movement physics-based and use forces to allow the
                        player to gain momentum and feel realistic. This did not turn out well. One of the main issues with this 
                        approach was that, well, realistic movement is realistic. The player needed time to counteract their momentum
                        if they wanted to change directions, resulting in very sluggish and unresponsive gameplay.
                    </p>
                    <p><br>
                        The next approach I tried was to still use physics but make the physics work in an unrealistic way. That is,
                        simulate forces on the player but modify how those forces act so that the movement feels snappy while still
                        giving the character a sense of weight and momentum. The hardest part of this was creating custom physics
                        to allow the player to have both a max speed when using basic inputs, as well as the ability to exceed that
                        max speed if an external force (such as an explosion) was applied to the character. Unfortunately, due to
                        time constraints, the game does not include any mechanics to generate explosive force. However, this
                        functionality can still be observed when using the dash ability.
                    </p>
                    <p><br>
                        Another aspect of this project that I learned a great deal from was the creation of the encounter system.
                        My main objective when planning and developing this system was to enable designers to streamline the creation
                        of encounters for each level. The primary way I accomplished this was through Unity's custom GUI tools.
                        I had always been interested in learning how to use these tools, so I made it my goal for this project to
                        utilize them to simplify aspects of design that would otherwise become tedious and inefficient.
                    </p>
                    <p><br>
                        This mindset led to the development of our encounter system. Using Unity's custom GUI tools, I created an editor
                        tool that allowed our designer to create "encounters" (hence the name encounter system). An encounter consisted
                        of a set number of waves, and each wave would spawn a specified number of enemies at various locations around
                        the encounter area. The editor tool also allowed the designer to drag all the enemies they wanted to spawn
                        in a wave, position them where they should spawn, and then simply press a single button to create a new wave
                        for the selected encounter. This process enabled our designer to rapidly create dynamic enemy encounters in
                        mere minutes, whereas previously it could have taken upwards of half an hour. Additionally, the tool handled
                        the implementation of waves and encounters into the game, meaning that once one was set up, we could immediately
                        test and iterate on it without requiring any extra integration steps.
                    </p>
                    <p><br>
                        I also wanted to experiment with creating a save/load system for this game to allow players to save their progress
                        and return later if they desired. This system became integrated into the game's checkpoint system as an autosave
                        feature. To elaborate further, each checkpoint doubles as a save point, saving your progress and storing it in
                        the designated save file. Every time you die, the game loads the saved data from your file and restarts you at
                        the checkpoint. The save file is also binary-encoded to prevent easy alteration.
                    </p>
                    <p><br>
                        <img src="images/Sterile_Coffin_UML.png" alt="Sterile Coffin Cover" id="main__img" style="float: right; margin-left: 15px; width: 1000px;">
                        As a way to visually document the relationships between all these systems, I maintained a basic UML diagram throughout the project
                        (with functions and variables omitted). Before working on any new system, I spent time integrating it into this UML diagram. Doing
                        this throughout the project made my code much cleaner and more decoupled, as I had already planned out the necessary relationships
                        beforehand and only added new ones when required.
                    </p>
                </div>


        </div>

        <div class="main__container">

            <div class="main__img--container">
                    <!-- This is where an image is loaded in -->
                <a href="https://plagatonicred.itch.io/2d-shooter-two-electric-boogaloo" target="_blank">
                    <img src="images/2D_Shooter2_Electric.png" alt="pic" id="main__img">
                    <img src="images/2D-Shooter-1.png" alt="pic" id="main__img">
                </a>
            </div>

            <div class="content shooter-2__content">
                <h1>2D-Shooter 2: Electric Boogaloo</h1>
                <!-- <h2>TECHNOLOGY</h2> -->
                <p>
                    2D-Shooter 2: Electric-Boogaloo is a top down, rogue-like, wave shooter where the player
                    takes control of a lone spaceship trying to survive as long as possible against ever increasingly
                    powerful alien fleets.
                </p>
                <button class="btn shooter-2__btn">
                    <p class="read-more">Read More</p>
                </button>
            </div>

            <div class="large-text-container">
                <p>
                    Development Time:
                    2 weeks
                    <br>
                    <br>
                    Team Size:
                    solo
                    <br>
                    <br>
                    Goals:
                    <br> Create a system that allows emergent gameplay
                    <br> Create a generic upgrade system that could be reused in future projects
                    <br> 
                    <br>
                    The creation process for this game is quite simple, I had been playing a lot of 
                    <a href="https://store.steampowered.com/app/1942280/Brotato/" target="_blank"> Brotato</a>
                    and had recently done a 48 hour gamejam where I attempted to create a similar auto-shooter wave game however,
                    the end project did not turn out as well as I had hoped. However, I still wanted to try my hand at the genre, 
                    and when my game-dev class tasked me with making a top down shooter for a project, I knew exactly 
                    what I wanted to do for said project. Thus, 2D-Shooter 2: Electric Boogaloo was born. 
                    (No there isn't a prequel to the game).
                    <br>
                    <br>
                    The biggest hurdle associated with this project was by far creating the upgrade system. In fact,
                    I would say that about half of my development time went into the creation of the upgrade system.
                    The biggest reason for this relatively long development time of one system was simply that I, at
                    this point, was inexperienced and had to spend a long amount of time thinking how I should handle
                    the upgrade implementation.
                    <br>
                    <br>
                    Firstly, I had to allow a way to dynamically change values across different scripts (preferably without
                    doing anything within update). I accomplished this by sending through the upgrade info as a parameter in an
                    event that would fire whenever the upgrade UI button was pressed, and this event would then trigger a function
                    that would change stored stat modifiers tied to each stat, Once this section of the system was done, everything
                    else fell into place nicely, and was mostly just UI and stat implementation. 
                    <br>
                    <br>
                    Secondly, I needed a way to apply
                    weights to each upgrade so that they were more or less likely to be chosen from the upgrade pool. While seemingly
                    simple, this took me quite a while to figure out, mostly due to me struggling to understand the math behind this 
                    process, however, I eventually figured this out and was able to implement a rarity system for the upgrades within
                    the game and my upgrade system was completed.
                    <br>
                    <br>
                    Unfortunately, after going back and trying to extract my upgrade system into it's own project for further development,
                    I came to the realization that I had not made the system as isolated as I had thought and a lot of the scripts were actually
                    quite tightly coupled to the game itself, so while I had made a functioning upgrade system for 2D-Shooter 2, I had not made 
                    a generic system that could be resused in future projects. Though, the time I spent on this upgrade system would eventually
                    lead me to make my upgrade System 3.0 (this being 2.0 and the gamejam version being 1.0).
                </p>
            </div>


        </div>

        <div class="main__container">

            <div class="main__img--container">
                <!-- This is where an image is loaded in -->
                <a href="https://plagatonicred.itch.io/welcome-to-sol" target="_blank">
                    <img src="images/Welcome_To_Sol.png" alt="pic" id="main__img">
                </a>
            </div>

            <div class="content main__content">
                <h1>Welcome to Sol</h1>
                <!-- <h2>TECHNOLOGY</h2> -->
                <p>
                    This is my first solo game project I made. A solar system simulator
                    that models the planets and their major moons orbits around the sun.
                </p>
                <button class="btn sol__btn">
                    <p class="read-more">Read More</p>
                </button>

            </div>

            <div class="large-text-container">
                <p>
                    Development Time:
                    2 weeks
                    <br>
                    <br>
                    Team Size:
                    solo
                    <br>
                    <br>
                    Goals:
                    <br> Create a realistic solar system simulation
                    <br> integrate my physics knowledge and interest in astronomy into a game
                </p>
                <p><br>
                    I've always had an interest in astronomy, ever since I was in kindergarten. 
                    I've also always loved watching videos on universe sandbox and been fascinated
                    by how one could develop such games.
                    So when my first game development class tasked us with making a solar system type project,
                    I was excstatic. However, what they wanted us to do was simply have planets rotate about each other
                    something that I thought was rather trivial given the complexity of planetary orbits. So, I decided to
                    make my own version of the project from scratch.
                </p>
                <p><br>                       
                    The first thing, and one of the most challenging, was properly integrating the formulas related to
                    orbital mechanics. I won't go too far into detail here, but I created custom physics to model the gravitational
                    interaction between bodies and also created functions that calculated the orbital path of an object about another.
                    I also wanted it to be as accurate as possible, so I used planetary data-sheets offered by NASA on their website and
                    integrated them into my simulation. I used scriptable objects to store each planets data and to allow for generalization
                    of planetary objects. This resulted in all bodies having (relatively) accurate rotational speeds, orbital inclinations, 
                    orbital speeds, eccentricity, etc. All in all it ended up taking me several hours to just input all the data for the 20 bodies that I included
                    in the game.
                </p>
                <p><br>
                    I also used real NASA mappings of many of the bodies (not all of them had complete texture mappings)
                    in order to texture each planet and many of the moons in order to further increase the accuracy of the solar
                    model. Finding these texture mappings also took quite a long time, especially some of the more obscure moons.
                    I also really wanted to provide a 1 to 1 scale distance between stellar bodies, using 1 unit in unity as 1meter
                    however, the distances between each bodie are so vast that it caused immense floating point errors just from the distances
                    between the sun and the Earth, so I had to scale it down by a factor of 100,000.
                    Regardless of this, I do still believe I was able to capture the shear magnitude of the distance between each planet
                    even if it isn't 100% to scale. The other issue, is that the shear difference in size between objects also resulted in floating point
                    imprecision, but instead for mesh vertices, this is particularly noticeable on phobos and deimos, the two smallest major moons in the
                    solar system.
                </p>
                <p><br>
                    I was, and still am, very happy with how this project turned out, I think it is one of my most
                    visually and statisically impressive projects, but as a game I do feel that it falls extremely short. 
                    In fact, I would say it's less of a game, and more of an interactive experience. None the less, it is
                    an interactive experience that I love showing to people and nerding out about all the different planetary
                    statistics I incorprorated into this project.
                </p>
            </div>

        </div>
    </div>

    <!-- This reads the footer.html and dynamically inserts it into the page -->
    <div id="footer-container"></div>
    <script>
        fetch('footer.html')
            .then(response => response.text())
            .then(html => {
                document.getElementById('footer-container').innerHTML = html;
            });
    </script>
    <script src="app.js" defer></script>
</body>
</html>